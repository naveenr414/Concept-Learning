from scipy.cluster.hierarchy import dendrogram, linkage, ward
from sklearn.cluster import AgglomerativeClustering
from scipy.spatial.distance import pdist, cdist
from scipy.sparse.csgraph import minimum_spanning_tree
import numpy as np

class Split:
    """Class that captures a split in a dendogram. 
        It essentially functions similar to a binary tree
        The left_split and right_split attributes are the child splits, 
        While the value is stored for leaf splits, where the height = 0
        
        Attributes:
            leaf: Boolean that says if split is a leaf Split
            left_split: Object from Split class that represents left child
            right_split: Object from Split class that represents right child
            split_height: Y coordinate at which the split occurs; 0 for leaves
            value: For leaf nodes, what value the nodes take up, as a list
                For non-leaf nodes, it's a sorted list of the values taken by their children
    """
      
    
    def __init__(self,split_height,left_split,right_split,value=None):
        if split_height == 0:
            self.leaf = True
            self.value = [value]

        else:
            self.leaf = False
            self.value = sorted(left_split.value + right_split.value)
        
        self.left_split = left_split
        self.right_split = right_split
        self.split_height = split_height 

class Hierarchy:
    """Stores a root split, and uses that to convert Hierarchies into numpy arrays and vice-versa
        This class is useful to investigate and print hierarchies, and also to compute distances
        
    Attributes:
        root_split: Split that contains information on all other splits
    """
    
    def __init__(self,root_split):
        self.root_split = root_split
        
    def from_array(self,arr):
        """From a numpy array, arr, generate the hierarchy and store it in root_split
        
        Arguments:
            arr: Numpy array generated by a hierarchy producing method from SkLearn
            
        Returns: Nothing
        
        Side Effects: Sets the data from arr to be in root_split
        """
        
    def to_array(self):
        """Return a numpy array from the data stored in root_split 
        
        Arguments: Nothing
        
        Returns: 
            Numpy array, with information on how to construct a histogram
        
        """
        
    def distance(self,other_hierarchy):
        """Distance from one hierarchy to another. 
            Calculated by converting hierarchy to a tree, then computing tree-edit distance
            
        Arguments:
            other_hierarchy: Another object from the class Hierarchy

        Returns: 
            float that represents distance between two hierarchies
        
        """
        
    def __str__(self):
        """Convert a hierarchy into a printable string
        
        Arguments: Nothing
        
        Returns:
            String which shows a human-understandable version of the dendrogram
            If dendogram is large, then we encourage saving it to a file         
        """

def create_ward_hierarchy(data,metric='euclidean'):
    """Use the sklearn ward function to construct a hierarchal cluster
    
    Arguments:
        data: Numpy array of data/array of numpy vectors

    Returns: 
        numpy array with information on how to construct a dendogram
    """
    
    dist = pdist(data,metric=metric)
    return ward(dist)

def create_linkage_hierarchy(data,method='single',metric='euclidean'):
    """Use the sklearn linkage function to construct a hierarchal cluster
    
    Arguments:
        data: Numpy array of data/array of numpy vectors
        method: What type of linkage, such as 'single', 'complete', or 'average'
        mertic: What metric to use, such as 'euclidean', 'chebyshev', 'cosine', etc.

    Returns:
        numpy array with information on how to construct a dendogram
        This can be fed into the dendrogram method to plot it
    """
    
    return linkage(data,method=method,metric=metric)

def create_hierarchy_thresholding(data,metric='euclidean'):
    """Use a thresholding algorithm with a minimum spanning tree to construct a hierarcha cluster
    
    Arguments:
        data: Numpy array of data/array of numpy vectors
        metric: What metric to use, such as 'euclidean', 'chebyshev', 'cosine', etc. 
        
    Returns:
        numpy array with information on how to construct a dendrogram
        This can be fed into the dendrogram method to plot it

    """
    
    distance_matrix = cdist(data,data,metric=metric)
    tree = minimum_spanning_tree(distance_matrix)
    tree = tree.toarray().astype(int)
    
    node_combinations = []
    for i in range(len(tree)):
        for j in range(len(tree[i])):
            if tree[i][j]>0:
                node_combinations.append((i,j,tree[i][j]))

    node_combinations = sorted(node_combinations,key=lambda k: k[2])
    
    # Create a matrix in the dendrogram format (https://stackoverflow.com/questions/9838861/scipy-linkage-format)
    return_matrix = np.zeros((len(data)-1,4))
    new_clusters = [[i] for i in range(len(data))]
    
    current_num = 0
    
    for u,v,dist in node_combinations:
        # Combine nodes u, v
        u_cluster = max([i for i in range(len(new_clusters)) if u in new_clusters[i]])
        v_cluster = max([i for i in range(len(new_clusters)) if v in new_clusters[i]])
            
        cluster_size = len(new_clusters[u_cluster]) + len(new_clusters[v_cluster])

        new_cluster = new_clusters[u_cluster] + new_clusters[v_cluster]
        new_cluster = list(set(new_cluster))
        new_clusters.append(new_cluster)
        
        return_matrix[current_num] = np.array([u_cluster,v_cluster,dist,cluster_size])
        current_num += 1
        
    return return_matrix